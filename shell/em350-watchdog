#!/bin/sh /etc/rc.common
USE_PROCD=1
START=99
STOP=10

SERIAL_DEVICE="/dev/ttyUSB2"
BAUD_RATE=115200
POLL_INTERVAL=10
INITIAL_DELAY=90
POST_DIAL_DELAY=30
MICROCOM_TIMEOUT=5000
PID_FILE="/var/run/em350.pid"

start_service() {
    procd_open_instance
    procd_set_param command /bin/sh -c "
        echo 'Starting EM350 watchdog...'
        sleep $INITIAL_DELAY

        if [ -f "/var/lock/LCK..ttyUSB2" ]; then
            rm -f "/var/lock/LCK..ttyUSB2"
        fi

        # 捕获退出信号，确保子进程终止
        trap 'kill \$(jobs -p) 2>/dev/null' EXIT

        while true; do
            RESPONSE=\$(echo -e 'AT^NDISSTATQRY?\r' | \
                microcom -t $MICROCOM_TIMEOUT -s $BAUD_RATE $SERIAL_DEVICE | \
                tr -d '\r')

            echo \"Raw response: \$RESPONSE\"

            STATUS_LINE=\$(echo \"\$RESPONSE\" | grep -m 1 'NDISSTATQRY:')
            if [ -n \"\$STATUS_LINE\" ]; then
                STATUS=\$(echo \"\$STATUS_LINE\" | sed -n 's/.*NDISSTATQRY: \\([0-9]\\),.*/\\1/p')
                case \$STATUS in
                    1) echo 'Status: Connected' ;;
                    0)
                        echo 'Status: Disconnected, dialing...'
                        # 启动后台进程但不分离
                        {
                            echo -e 'AT^NDISDUP=1,1\r' | microcom -t $MICROCOM_TIMEOUT -s $BAUD_RATE $SERIAL_DEVICE
                            sleep 5
                            udhcpc -i wwan0 -q -n
                        } &
                        sleep $POST_DIAL_DELAY
                        ;;
                    *) echo \"Unknown status: \$STATUS\" ;;
                esac
            else
                echo \"Error: Invalid response\"
                echo \"\$RESPONSE\" | hexdump -C
            fi
            sleep $POLL_INTERVAL
        done"

    procd_set_param respawn 300 5 0
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param pidfile "$PID_FILE"
    procd_close_instance
}

stop_service() {
    echo "Stopping EM350 watchdog..."

    # 安全停止方法（不杀死进程组）
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")

        # 仅终止当前进程
        kill "$PID" 2>/dev/null
        sleep 1

        # 检查并强制终止（避免影响其他进程）
        if [ -d "/proc/$PID" ]; then
            kill -9 "$PID" 2>/dev/null
        fi

        rm -f "$PID_FILE"
    fi
}

status_service() {
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        echo "running"
        return 0
    else
        echo "stopped"
        return 1
    fi
}
